# Тест 2. Массивы. Слайсы. Map

1. Что выведет код?

   ```go
   package main

   import (
       "fmt"
   )

   func main() {
       a := []int{1, 2, 3}
       fmt.Println(a[:1])
   }
   ```

   - [ ] []
   - [ ] [1]
   - [ ] [1 2]
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [ ] []
   - [x] **[1]**
   - [ ] [1 2]
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   **Объяснение:**

   Мы получаем слайс с начала массива по элемент с индексом 1 (это второй элемент), но не включаем его. Т.е. на выходе получаем слайс только из первого элемента.

   </details>

1. Что выведет код?

   ```go
   package main

   import (
       "fmt"
   )

   func main() {
       a := []int{1, 2, 3}
       fmt.Println(a[:3])
   }
   ```

   - [ ] [1 2]
   - [ ] [1 2 3]
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [ ] [1 2]
   - [x] **[1 2 3]**
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   **Объяснение:**
   Мы получаем слайс с начала массива по элемент с индексом 3 (это четвертый элемент), но не включаем его. Т.е. на выходе получаем слайс с такими же границами, как и `a`.

   </details>

1. Что выведет код?

   ```go
   package main

   import (
       "fmt"
   )

   func main() {
       a := []int{1, 2, 3}
       fmt.Println(a[:4])
   }
   ```

   - [ ] Результат не определен
   - [ ] [1 2 3]
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [ ] Результат не определен
   - [ ] [1 2 3]
   - [ ] Код не скомпилируется
   - [x] **Код запаникует**

   **Объяснение:**

   Мы получаем слайс с начала массива по элемент с индексом 4 (это пятый элемент), но не включаем его. Поскольку у слайса нет четвертого элемента, то мы пытаемся взять слайс за границей доступной памяти. Такая операция приведет к панике
   </details>

1. Что выведет код?

   ```go
   package main

   import (
       "fmt"
   )

   func main() {
       a := []int{1, 2, 3}
       fmt.Println(a[1:2:3])
   }
   ```

   - [ ] []
   - [ ] [1]
   - [ ] [2]
   - [ ] [1 2]
   - [ ] [2 3]
   - [ ] [1 2 3]
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [ ] []
   - [ ] [1]
   - [x] **[2]**
   - [ ] [1 2]
   - [ ] [2 3]
   - [ ] [1 2 3]
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   **Объяснение:**

   Получаем слайс с элемента с индексом 1 включительно (второй элемент) до элемента с индексом 2 исключительно (третий элемент) и корректной границей `max` по вместимости (граница не выходит за пределы доступной памяти).
   </details>

1. Что выведет код?

   ```go
   package main

   import (
       "fmt"
   )

   func main() {
       a := []int{1, 2, 3}
       fmt.Println(a[1::3])
   }
   ```

   - [ ] []
   - [ ] [1]
   - [ ] [2]
   - [ ] [1 2]
   - [ ] [2 3]
   - [ ] [1 2 3]
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [ ] []
   - [ ] [1]
   - [ ] [2]
   - [ ] [1 2]
   - [ ] [2 3]
   - [ ] [1 2 3]
   - [x] **Код не скомпилируется**
   - [ ] Код запаникует

   **Объяснение:**

   Задание границы `max` требует обязательного указания верхней границы `high` нового слайса. Поэтому данный синтаксис является некорректным
   </details>

1. Что выведет код?

   ```go
   package main

   import (
       "fmt"
   )

   func main() {
       a := []int{1, 2, 3}
       fmt.Println(a[:2:3])
   }
   ```

   - [ ] []
   - [ ] [1]
   - [ ] [2]
   - [ ] [1 2]
   - [ ] [2 3]
   - [ ] [1 2 3]
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [ ] []
   - [ ] [1]
   - [ ] [2]
   - [x] **[1 2]**
   - [ ] [2 3]
   - [ ] [1 2 3]
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   **Объяснение:**

   Получаем слайс от начала до элемента с индексом 2 (третий элемент), не включая его. При этом указываем корректное ограничение вместимости `max`.
   </details>

1. Что выведет код?

   ```go
   package main

   import (
       "fmt"
   )

   func main() {
       a := []int{1, 2, 3}
       fmt.Println(a[1:2:])
   }
   ```

   - [ ] []
   - [ ] [1]
   - [ ] [2]
   - [ ] [1 2]
   - [ ] [2 3]
   - [ ] [1 2 3]
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [ ] []
   - [ ] [1]
   - [ ] [2]
   - [ ] [1 2]
   - [ ] [2 3]
   - [ ] [1 2 3]
   - [x] **Код не скомпилируется**
   - [ ] Код запаникует

   **Объяснение:**

   Данный синтаксис слайса является некорректным. Если требуется опустить значение `max`, то не стоит указывать второе многоточие.
   </details>

1. Что выведет код?

   ```go
   package main

   import (
       "fmt"
   )

   func main() {
       a := []int{1, 2, 3}
       fmt.Println(a[1:])
   }
   ```

   - [ ] []
   - [ ] [1]
   - [ ] [2]
   - [ ] [1 2]
   - [ ] [2 3]
   - [ ] [1 2 3]
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [ ] []
   - [ ] [1]
   - [ ] [2]
   - [ ] [1 2]
   - [x] **[2 3]**
   - [ ] [1 2 3]
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   **Объяснение:**

   Получаем слайс начиная с элемента с индексом 1 включительно (второй элемент) до конца слайса.
   </details>

1. Что выведет код?

   ```go
   package main

   import (
       "fmt"
   )

   func main() {
       a := []int{1, 2, 3}
       fmt.Println(a[:])
   }
   ```

   - [ ] []
   - [ ] [1]
   - [ ] [2]
   - [ ] [1 2]
   - [ ] [2 3]
   - [ ] [1 2 3]
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [ ] []
   - [ ] [1]
   - [ ] [2]
   - [ ] [1 2]
   - [ ] [2 3]
   - [x] **[1 2 3]**
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   **Объяснение:**

   Когда опущено значение `low` в синтаксисе слайса, вместо него берется 0.

   Когда опущено значение `high` в синтаксисе слайса, вместо него берется длина массива/слайса.

   В данном случае получаем слайс начиная с элемента с индексом 0 включительно (первый элемент) до конца слайса. Т.е. получаем аналогичный слайс.
   </details>

1. Что выведет код?

   ```go
   package main

   import (
       "fmt"
   )

   func main() {
       a := []int{}
       a = append(a, 1)
       a = append(a, 2)
       a = append(a, 3)
       add(a)
       fmt.Println(a)
   }

   func add(a []int) {
       a = append(a, 4)
   }
   ```

   - [ ] [1 2 3]
   - [ ] [1 2 3 4]
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [x] **[1 2 3]**
   - [ ] [1 2 3 4]
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   **Объяснение:**

   Вместимость слайса при передаче в функцию `add` равна 4 при длине 3.

   При попытке добавления в конец слайса не происходит реаллокации слайса. Поэтому мы записываем 4 в конец массива, на который ссылается исходный слайс `a`.

   Но как мы помним, слайс состоит из ссылки на адрес памяти, а также `len` и `cap`. После выхода из функции `add` уничтожается копия слайса `a` с длиной 4.

   Как итог, в значении `a` остается слайс с длиной `3` и вместимостью `4`. Несмотря на то, что функция `add` поменяла четвертый элемент массива, на который ссылается слайс `a`, на 4, будут выведены только первый три значения
   </details>

1. Что выведет код?

   ```go
   package main

   import (
       "fmt"
   )

   func main() {
       var a []int
       a = append(a, 1)
       fmt.Println(a)
   }

   ```

   - [ ] [1]
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [x] **[1]**
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   **Объяснение:**

   Zero-value для `[]int` - `nil`. `nil` ведет себя ровно так же, как и слайс нулевой длины. В частности, к нему можно без ошибок добавлять элементы функцией `append`
   </details>

1. Что выведет код?

   ```go
   package main

   import "fmt"

   func main() {
       a := [2]int{0, 0}

       if a == nil {
           fmt.Println("true")
       } else {
           fmt.Println("false")
       }
   }
   ```

   - [ ] true
   - [ ] false
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [ ] true
   - [ ] false
   - [x] **Код не скомпилируется**
   - [ ] Код запаникует

   **Объяснение:**

   `nil` - некорректное значение для массивов. Поэтому попытка сравнения массива с `nil` не пройдет компиляцию
   </details>

1. Что выведет код?

   ```go
   package main

   import "fmt"

   func main() {
       a := [2]int{0, 0}

       if a == [2]int{} {
           fmt.Println("true")
       } else {
           fmt.Println("false")
       }
   }
   ```

   - [ ] true
   - [ ] false
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [x] **true**
   - [ ] false
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   **Объяснение:**

   Массивы сравниваются по значению.

   В конструкции `[2]int{}` необъявленные элементы заполняются нулями. Т.е. `[2]int{0}`, `[2]int{0, 0}` и `[2]int{}` - это одно и то же.
   </details>

1. Что выведет код?

   ```go
   package main

   import "fmt"

   func main() {
       a := [2]int{1, 2}

       if a == [2]int{} {
           fmt.Println("true")
       } else {
           fmt.Println("false")
       }
   }
   ```

   - [ ] true
   - [ ] false
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [ ] true
   - [x] **false**
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   **Объяснение:**

   Массивы сравниваются по значению.

   В конструкции `[2]int{}` необъявленные элементы заполняются нулями. Т.е. `[2]int{0}`, `[2]int{0, 0}` и `[2]int{}` - это одно и то же.
   </details>

1. Что выведет код?

   ```go
   package main

   import "fmt"

   func main() {
       a := [0]int{}

       fmt.Println(a)
   }
   ```

   - [ ] []
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [x] **[]**
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   **Объяснение:**

   Массив может иметь нулевой размер. Это вполне допустимая ситуация
   </details>

1. Что выведет код?

   ```go
   package main

   import "fmt"

   func main() {
       a := []int{}

       if a == nil {
           fmt.Println("true")
       } else {
           fmt.Println("false")
       }
   }
   ```

   - [ ] true
   - [ ] false
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [ ] true
   - [x] **false**
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   **Объяснение:**

   Слайс можно сравнить с `nil`. Однако `[]int{}` - это не `nil`-слайс, а просто пустой слайс. Поэтому он не равен `nil`, хотя в остальном он ведет себя абсолютно аналогично.
   </details>

1. Что выведет код?

   ```go
   package main

   import "fmt"

   func main() {
       a := []int{}

       if a == []int{} {
           fmt.Println("true")
       } else {
           fmt.Println("false")
       }
   }
   ```

   - [ ] true
   - [ ] false
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [ ] true
   - [ ] false
   - [x] **Код не скомпилируется**
   - [ ] Код запаникует

   **Объяснение:**

   Слайс можно сравнить _только_ с `nil`. Сравнивать слайсы друг с другом - недопустимая операция.
   </details>

1. Что выведет код?

   ```go
   package main

   import "fmt"

   func main() {
       m := map[[2]int]int{
           {1, 2}: 3,
       }

       fmt.Println(m[[2]int{1, 2}])
   }
   ```

   - [ ] 0
   - [ ] 3
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [ ] 0
   - [x] **3**
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   **Объяснение:**

   Массив - корректный тип для ключа `map`, поскольку он поддерживает сравнение на равенство.
   </details>

1. Что выведет код?

   ```go
   package main

   import "fmt"

   func main() {
       m := map[[]int]int{
           {1, 2}: 3,
       }

       fmt.Println(m[[]int{1, 2}])
   }
   ```

   - [ ] 0
   - [ ] 3
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [ ] 0
   - [ ] 3
   - [x] **Код не скомпилируется**
   - [ ] Код запаникует

   **Объяснение:**

   Слайс - недопустимый тип для ключа `map`, поскольку он не поддерживает сравнение на равенство.
   </details>

1. Что выведет код?

   ```go
   package main

   import "fmt"

   func main() {
       m := map[string]int{}

       if m == nil {
           fmt.Println("true")
       } else {
           fmt.Println("false")
       }
   }
   ```

   - [ ] true
   - [ ] false
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [ ] true
   - [x] **false**
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   **Объяснение:**

   `map` можно сравнить с `nil`. Однако `map[string]int{}` - это не `nil`-map
   </details>

1. Что выведет код?

   ```go
   package main

   import "fmt"

   func main() {
       m := map[string]int{}

       if m == map[string]int{} {
           fmt.Println("true")
       } else {
           fmt.Println("false")
       }
   }
   ```

   - [ ] true
   - [ ] false
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [ ] true
   - [ ] false
   - [x] **Код не скомпилируется**
   - [ ] Код запаникует

   **Объяснение:**

   `map` можно сравнить _только_ с `nil`. Сравнивать `map` друг с другом - недопустимая операция.
   </details>

1. Что выведет код?

   ```go
   package main

   import "fmt"

   func main() {
       m := map[string]int{}

       m["one"] = 1

       fmt.Println(m)
   }
   ```

   - [ ] map[one:1]
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [x] **map[one:1]**
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   **Объяснение:**

   Корректно инициализированный `map` автоматически расширяется при записи новых значений.
   </details>

1. Что выведет код?

   ```go
   package main

   import "fmt"

   func main() {
       var m map[string]int

       m["one"] = 1

       fmt.Println(m)
   }
   ```

   - [ ] map[one:1]
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [ ] map[one:1]
   - [ ] Код не скомпилируется
   - [x] **Код запаникует**

   **Объяснение:**

   Zero-value для `map[string]int` - это `nil`. Попытка записи в `nil`-map приведет к панике `panic: assignment to entry in nil map`
   </details>

1. Что выведет код?

   ```go
   package main

   import "fmt"

   func main() {
       var m map[string]int

       fmt.Println(m["one"])
   }
   ```

   - [ ] 0
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   <details>
   <summary>Ответ с пояснением</summary>

   - [x] **0**
   - [ ] Код не скомпилируется
   - [ ] Код запаникует

   **Объяснение:**

   Zero-value для `map[string]int` - это `nil`. Попытка чтения из `nil`-map - вполне допустимая операция. При этом будет прочитано zero-value типа `int` - 0.
   </details>
