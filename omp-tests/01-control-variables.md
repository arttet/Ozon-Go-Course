# Тест 1. Управляющие конструкции. Переменные

1.  Выберите строки, которые выведет программа.

    ```go
    package main

    import (
        "fmt"
    )

    func main() {
        a := 2

        switch a {
        case 1:
            fmt.Println("one")
        case 2:
            fmt.Println("two")
        case 3:
            fmt.Println("three")
            break
        default:
            fmt.Println("default")
        }
    }
    ```

    - [ ] one
    - [ ] two
    - [ ] three
    - [ ] default

    <details>
    <summary>Ответ с пояснением</summary>

    - [ ] one
    - [x] **two**
    - [ ] three
    - [ ] default

    **Объяснение:**

    `break` прерывает выполнение ветки `case`. Но поскольку он находится в конце ветки, он не возымеет никакого эффекта.

    Кстати, есть линтеры, которые ругались бы на такую конструкцию `break` как на бессмысленную.
    </details>

1.  Выберите строки, которые выведет программа.

    ```go
    package main

    import (
        "fmt"
    )

    func main() {
        a := 2

        switch a {
        case 1:
            fmt.Println("one")
        case 2:
            fmt.Println("two")
            fallthrough
        case 3:
            fmt.Println("three")
            fallthrough
        default:
            fmt.Println("default")
        }
    }
    ```

    - [ ] one
    - [ ] two
    - [ ] three
    - [ ] default

    <details>
    <summary>Ответ с пояснением</summary>

    - [ ] one
    - [x] **two**
    - [x] **three**
    - [x] **default**

    **Объяснение:**

    `fallthrough` приводит к выполнению следующей ветки `case`/`default`.
    </details>

1.  Выберите строки, которые выведет программа.

    ```go
    package main

    import (
        "fmt"
    )

    func main() {
        a := 5
        switch {
        case a > 1:
            fmt.Println("a > 1")
            fallthrough
        case a > 2:
            fmt.Println("a > 2")
            break
        case a > 3:
            fmt.Println("a > 3")
        default:
            fmt.Println("default")
        }
    }
    ```

    - [ ] a > 1
    - [ ] a > 2
    - [ ] a > 3
    - [ ] default

    <details>
    <summary>Ответ с пояснением</summary>

    - [x] **a > 1**
    - [x] **a > 2**
    - [ ] a > 3
    - [ ] default

    **Объяснение:**

    `fallthrough` приводит к выполнению следующей ветки `case`/`default`. `break` в конце ветки `case` не имеет никакого эффекта, поскольку предназначен для преждевременного выхода из ветки.
    </details>

1.  Что выведет код?

    ```go
    package main

    import (
        "fmt"
    )

    func main() {
        m := map[string]int{
            "one": 1,
        }

        if value, ok := m["one"]; ok {
            fmt.Println("one exists!")
        }

        fmt.Println(value)
    }
    ```

    - [ ] 0
    - [ ] 1
    - [ ] "one exists!", 0
    - [ ] "one exists!", 1
    - [ ] Код не скомпилируется
    - [ ] Код запаникует

    <details>
    <summary>Ответ с пояснением</summary>

    - [ ] 0
    - [ ] 1
    - [ ] "one exists!", 0
    - [ ] "one exists!", 1
    - [x] **Код не скомпилируется**
    - [ ] Код запаникует

    **Объяснение:**

    Область видимости переменной `value` ограничивается конструкцией `if`. Поэтому компилятор укажет на необъявленную переменную `value`.
    </details>

1.  Что выведет код?

    ```go
    package main

    import (
        "fmt"
    )

    func main() {
        m := map[string]int{
            "one": 1,
        }

        value := 5

        if value, ok := m["one"]; ok {
            fmt.Println("one exists!")
        }

        fmt.Println(value)
    }
    ```

    - [ ] 1
    - [ ] 5
    - [ ] "one exists!", 1
    - [ ] "one exists!", 5
    - [ ] Код не скомпилируется
    - [ ] Код запаникует

    <details>
    <summary>Ответ с пояснением</summary>

    - [ ] 1
    - [ ] 5
    - [ ] "one exists!", 1
    - [ ] "one exists!", 5
    - [x] **Код не скомпилируется**
    - [ ] Код запаникует

    **Объяснение:**

    В данном коде объявлено две разные переменные с именем `value` - одна на уровне `main`, и другая - в области видимости конструкции `if`.

    Конструкция `if` объявляет две переменные - `value` и `ok`. Однако переменная `value`, объявленная внутри блока `if`, не используется.

    Язык Go запрещает объявление неиспользованных переменных по причине борьбы с ошибками, а также в целях повышения скорости компиляции - https://golang.org/doc/faq#unused_variables_and_imports . Поэтому данный код не скомпилируется
    </details>

1.  Что выведет код?

    ```go
    package main

    import (
        "fmt"
    )

    func main() {
        m := map[string]int{
            "one": 1,
        }

        value := 5

        if value, ok := m["one"]; ok {
            fmt.Println(value)
        }

        fmt.Println(value)
    }
    ```

    - [ ] 1
    - [ ] 5
    - [ ] 1, 1
    - [ ] 1, 5
    - [ ] Код не скомпилируется
    - [ ] Код запаникует

    <details>
    <summary>Ответ с пояснением</summary>

    - [ ] 1
    - [ ] 5
    - [ ] 1, 1
    - [x] **1, 5**
    - [ ] Код не скомпилируется
    - [ ] Код запаникует

    **Объяснение:**

    В данном коде объявлено две разные переменные с именем `value` - одна на уровне `main`, и другая - в области видимости конструкции `if`.

    Конструкция `if` объявляет две переменные - `value` и `ok`. Переменная `value` внутри `if` равна результату инициализации значением `m["one"]`, однако после завершения конструкции `if` эта переменная становится недоступна.
    </details>

1.  Что выведет код?

    ```go
    package main

    import (
        "fmt"
    )

    func main() {
        m := map[string]int{
            "zero": 0,
        }

        value := 5

        if value, ok := m["one"]; ok {
            fmt.Println(value)
        }

        fmt.Println(value)
    }
    ```

    - [ ] 0
    - [ ] 5
    - [ ] 0, 0
    - [ ] 0, 5
    - [ ] Код не скомпилируется
    - [ ] Код запаникует

    <details>
    <summary>Ответ с пояснением</summary>

    - [ ] 0
    - [x] **5**
    - [ ] 0, 0
    - [ ] 0, 5
    - [ ] Код не скомпилируется
    - [ ] Код запаникует

    **Объяснение:**
    В данном коде объявлено две разные переменные с именем `value` - одна на уровне `main`, и другая - в области видимости конструкции `if`.

    Конструкция `if` объявляет две переменные - `value` и `ok`. Переменная `value` внутри `if` равна результату инициализации значением `m["one"]` (0, поскольку ключ `"one"` отсутствует в `m`), однако после завершения конструкции `if` эта переменная становится недоступна. Переменная `ok` равна `false`, поскольку ключ отсутствует в словаре. Как следствие, конструкция `if` не выполняется и мы видим только вывод внешней переменной `value`.
    </details>

1.  Что выведет код?

    ```go
    package main

    import (
        "fmt"
    )

    var a = 3

    func main() {
        a := 4

        fmt.Println(a)
    }
    ```

    - [ ] 3
    - [ ] 4
    - [ ] Код не скомпилируется
    - [ ] Код запаникует

    <details>
    <summary>Ответ с пояснением</summary>

    - [ ] 3
    - [x] **4**
    - [ ] Код не скомпилируется
    - [ ] Код запаникует

    **Объяснение:**

    В данном коде объявлено две разные переменные с именем `a` - одна в глобальной области видимости, и другая - в области видимости функции `main`.

    Мы определяем и выводим значение переменной, объявленной на уровне функции `main`
    </details>

1.  Что выведет код?

    ```go
    package main

    import (
        "fmt"
    )

    var a = 3

    func main() {
        fmt.Println(a)
    }
    ```

    - [ ] 3
    - [ ] Код не скомпилируется
    - [ ] Код запаникует

    <details>
    <summary>Ответ с пояснением</summary>

    - [x] **3**
    - [ ] Код не скомпилируется
    - [ ] Код запаникует

    **Объяснение:**

    В данном коде корректно объявлена переменная с именем `a` в глобальной области видимости. Внутри функции `main` выводится её значение.
    </details>

1.  Что выведет код?

    ```go
    package main

    import (
        "fmt"
    )

    a := 3

    func main() {
        fmt.Println(a)
    }
    ```

    - [ ] 3
    - [ ] Код не скомпилируется
    - [ ] Код запаникует

    <details>
    <summary>Ответ с пояснением</summary>

    - [ ] 3
    - [x] **Код не скомпилируется**
    - [ ] Код запаникует

    **Объяснение:**

    Конструкцию `:=` можно использовать только для объявления переменных в локальной области видимости. В глобальной области видимости переменную можно объявить только через `var`
    </details>
